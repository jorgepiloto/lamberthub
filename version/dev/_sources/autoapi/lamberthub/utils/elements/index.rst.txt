:mod:`lamberthub.utils.elements`
================================

.. py:module:: lamberthub.utils.elements
   :noindex:

.. autoapi-nested-parse::

   Holds routines for converting between different orbital elements sets.

   .. note::
       Some of these functions were directly taken from the poliastro[1] library,
       see the references section for more information about this powerful
       software.

       Copyright (c) 2012-2021 Juan Luis Cano Rodr√≠guez and the poliastro
       development team.

   .. rubric:: References

   [1] poliastro: https://github.com/poliastro/poliastro/



Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::


   lamberthub.utils.elements.rv_pqw


   lamberthub.utils.elements.coe_rotation_matrix


   lamberthub.utils.elements.coe2rv


   lamberthub.utils.elements.rv2coe


   lamberthub.utils.elements.rotation_matrix



.. py:function:: rv_pqw(k, p, ecc, nu)

   Returns r and v vectors in perifocal frame.

   :param k: Standard gravitational parameter (km^3 / s^2).
   :type k: float
   :param p: Semi-latus rectum or parameter (km).
   :type p: float
   :param ecc: Eccentricity.
   :type ecc: float
   :param nu: True anomaly (rad).
   :type nu: float

   :returns: * **r** (*ndarray*) -- Position. Dimension 3 vector
             * **v** (*ndarray*) -- Velocity. Dimension 3 vector

   .. rubric:: Notes

   These formulas can be checked at Curtis 3rd. Edition, page 110. Also the
   example proposed is 2.11 of Curtis 3rd Edition book.

   .. math::

       \vec{r} = \frac{h^2}{\mu}\frac{1}{1 + e\cos(\theta)}\begin{bmatrix}
       \cos(\theta)\\
       \sin(\theta)\\
       0
       \end{bmatrix} \\\\\\

       \vec{v} = \frac{h^2}{\mu}\begin{bmatrix}
       -\sin(\theta)\\
       e+\cos(\theta)\\
       0
       \end{bmatrix}


.. py:function:: coe_rotation_matrix(inc, raan, argp)

   Create a rotation matrix for coe transformation


.. py:function:: coe2rv(k, p, ecc, inc, raan, argp, nu)

   Converts from classical orbital to state vectors.

   Classical orbital elements are converted into position and velocity
   vectors by `rv_pqw` algorithm. A rotation matrix is applied to position
   and velocity vectors to get them expressed in terms of an IJK basis.

   :param k: Standard gravitational parameter (km^3 / s^2).
   :type k: float
   :param p: Semi-latus rectum or parameter (km).
   :type p: float
   :param ecc: Eccentricity.
   :type ecc: float
   :param inc: Inclination (rad).
   :type inc: float
   :param omega: Longitude of ascending node (rad).
   :type omega: float
   :param argp: Argument of perigee (rad).
   :type argp: float
   :param nu: True anomaly (rad).
   :type nu: float

   :returns: * **r_ijk** (*np.array*) -- Position vector in basis ijk.
             * **v_ijk** (*np.array*) -- Velocity vector in basis ijk.

   .. rubric:: Notes

   .. math::
       \begin{align}
           \vec{r}_{IJK} &= [ROT3(-\Omega)][ROT1(-i)][ROT3(-\omega)]\vec{r}_{PQW}
                              = \left [ \frac{IJK}{PQW} \right ]\vec{r}_{PQW}\\
           \vec{v}_{IJK} &= [ROT3(-\Omega)][ROT1(-i)][ROT3(-\omega)]\vec{v}_{PQW}
                              = \left [ \frac{IJK}{PQW} \right ]\vec{v}_{PQW}\\
       \end{align}

   Previous rotations (3-1-3) can be expressed in terms of a single rotation matrix:

   .. math::
       \left [ \frac{IJK}{PQW} \right ]

   .. math::
       \begin{bmatrix}
       \cos(\Omega)\cos(\omega) - \sin(\Omega)\sin(\omega)\cos(i) & -\cos(\Omega)\sin(\omega) - \sin(\Omega)\cos(\omega)\cos(i) & \sin(\Omega)\sin(i)\\
       \sin(\Omega)\cos(\omega) + \cos(\Omega)\sin(\omega)\cos(i) & -\sin(\Omega)\sin(\omega) + \cos(\Omega)\cos(\omega)\cos(i) & -\cos(\Omega)\sin(i)\\
       \sin(\omega)\sin(i) & \cos(\omega)\sin(i) & \cos(i)
       \end{bmatrix}


.. py:function:: rv2coe(k, r, v, tol=1e-08)

   Converts from vectors to classical orbital elements.

   :param k: Standard gravitational parameter (km^3 / s^2)
   :type k: float
   :param r: Position vector (km)
   :type r: array
   :param v: Velocity vector (km / s)
   :type v: array
   :param tol: Tolerance for eccentricity and inclination checks, default to 1e-8
   :type tol: float, optional

   :returns: * **p** (*float*) -- Semi-latus rectum of parameter (km)
             * **ecc** (*float*) -- Eccentricity
             * **inc** (*float*) -- Inclination (rad)
             * **raan** (*float*) -- Right ascension of the ascending nod (rad)
             * **argp** (*float*) -- Argument of Perigee (rad)
             * **nu** (*float*) -- True Anomaly (rad)

   .. rubric:: Notes

   This example is a real exercise from Orbital Mechanics for Engineering
   students by Howard D.Curtis. This exercise is 4.3 of 3rd. Edition, page 200.

   1. First the angular momentum is computed:

   .. math::
       \vec{h} = \vec{r} \times \vec{v}

   2. With it the eccentricity can be solved:

   .. math::
       \begin{align}
       \vec{e} &= \frac{1}{\mu}\left [ \left ( v^{2} - \frac{\mu}{r}\right ) \vec{r}  - (\vec{r} \cdot \vec{v})\vec{v} \right ] \\
       e &= \sqrt{\vec{e}\cdot\vec{e}} \\
       \end{align}

   3. The node vector line is solved:

   .. math::
       \begin{align}
       \vec{N} &= \vec{k} \times \vec{h} \\
       N &= \sqrt{\vec{N}\cdot\vec{N}}
       \end{align}

   4. The right ascension node is computed:

   .. math::
       \Omega = \left\{ \begin{array}{lcc}
        cos^{-1}{\left ( \frac{N_{x}}{N} \right )} &   if  & N_{y} \geq  0 \\
        \\ 360^{o} -cos^{-1}{\left ( \frac{N_{x}}{N} \right )} &  if & N_{y} < 0 \\
        \end{array}
       \right.

   5. The argument of perigee:

   .. math::
       \omega  = \left\{ \begin{array}{lcc}
        cos^{-1}{\left ( \frac{\vec{N}\vec{e}}{Ne} \right )} &   if  & e_{z} \geq  0 \\
        \\ 360^{o} -cos^{-1}{\left ( \frac{\vec{N}\vec{e}}{Ne} \right )} &  if & e_{z} < 0 \\
        \end{array}
       \right.

   6. And finally the true anomaly:

   .. math::
       \nu  = \left\{ \begin{array}{lcc}
        cos^{-1}{\left ( \frac{\vec{e}\vec{r}}{er} \right )} &   if  & v_{r} \geq  0 \\
        \\ 360^{o} -cos^{-1}{\left ( \frac{\vec{e}\vec{r}}{er} \right )} &  if & v_{r} < 0 \\
        \end{array}
       \right.


.. py:function:: rotation_matrix(angle, axis)


